"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserCount = exports.sendMessage = exports.readMessagesForAll = exports.enqueueUserFetch = exports.registerUser = exports.isRegistered = exports.initUsers = exports.stopMessageFetchProcess = exports.startMessageFetchProcess = exports.stopUserFetchProcess = exports.startUserFetchProcess = exports.initChatRoom = exports.getChatActions = exports.setBeeUrl = void 0;
const bee_js_1 = require("@ethersphere/bee-js");
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const eventEmitter_1 = require("./eventEmitter");
const asyncQueue_1 = require("./asyncQueue");
const constants_1 = require("./constants");
let bee = new bee_js_1.Bee('http://195.88.57.155:1633');
function setBeeUrl(url) {
    bee = new bee_js_1.Bee(url);
}
exports.setBeeUrl = setBeeUrl;
// TODO this whole thing should be a class
const emitter = new eventEmitter_1.EventEmitter();
const messages = [];
const reqTimeAvg = new utils_1.RunningAverage(1000);
let usersQueue;
let messagesQueue;
let users = [];
//let inactiveUsers: UserWithIndex[] = [];                              // Currently not polling messages from these users
let usersLoading = false;
let usersFeedIndex = 0; // Will be overwritten on user-side, by initUsers
let ownIndex;
let removeIdleUsersInterval = null; // Streamer-side interval, for idle user removing
let userFetchInterval = null; // User-side interval, for user fetching
let messageFetchInterval = null; // User-side interval, for message fetching
let mInterval = constants_1.MESSAGE_FETCH_MIN * 3; // We initialize message fetch interval to higher than min, we don't know network conditions yet
let messagesIndex = 0;
let removeIdleIsRunning = false; // Avoid race conditions
let userActivityTable = {}; // Used to remove inactive users
let newlyResigeredUsers = []; // keep track of fresh users
// Diagnostics
let reqCount = 0;
// Which operation is in progress, if any
const eventStates = {
    loadingInitUsers: false,
    loadingUsers: false,
    loadingRegistration: false,
};
function getChatActions() {
    return {
        startFetchingForNewUsers: enqueueUserFetch,
        startLoadingNewMessages: readMessagesForAll,
        on: emitter.on,
        off: emitter.off,
    };
}
exports.getChatActions = getChatActions;
// Creates the Users feed, which is necesarry for user registration, and to handle idle users
// Should be called from outside the library, for example React
async function initChatRoom(topic, stamp) {
    try {
        const { consensusHash, graffitiSigner } = (0, utils_1.generateGraffitiFeedMetadata)(topic);
        await bee.createFeedManifest(stamp, 'sequence', consensusHash, graffitiSigner.address);
    }
    catch (error) {
        console.error(error);
        throw new Error('Could not create Users feed');
    }
}
exports.initChatRoom = initChatRoom;
// startUserFetchProcess will periodically read the Users feed
// Should be called from outside the library, for example React
function startUserFetchProcess(topic) {
    if (userFetchInterval) {
        clearInterval(userFetchInterval);
    }
    userFetchInterval = setInterval(enqueueUserFetch(topic), constants_1.USER_UPDATE_INTERVAL);
}
exports.startUserFetchProcess = startUserFetchProcess;
// stopUserFetchProcess clears the interval, that periodically reads the Users feed
// Should be called from outside the library, for example React
function stopUserFetchProcess() {
    if (userFetchInterval) {
        clearInterval(userFetchInterval);
        userFetchInterval = null;
    }
}
exports.stopUserFetchProcess = stopUserFetchProcess;
// startMessageFetchProcess will periodically read next message, for all active users
// Should be called from outside the library, for example React
function startMessageFetchProcess(topic) {
    if (messageFetchInterval) {
        clearInterval(messageFetchInterval);
    }
    messageFetchInterval = setInterval(readMessagesForAll(topic), mInterval);
}
exports.startMessageFetchProcess = startMessageFetchProcess;
// clears the interval, that periodically reads messages for all active users
// Should be called from outside the library, for example React
function stopMessageFetchProcess() {
    if (messageFetchInterval) {
        clearInterval(messageFetchInterval);
        messageFetchInterval = null;
    }
}
exports.stopMessageFetchProcess = stopMessageFetchProcess;
// Initializes the users object, when starting the application
// Should be called from outside the library, for example React
async function initUsers(topic, ownAddress, stamp) {
    try {
        emitStateEvent(constants_1.EVENTS.LOADING_INIT_USERS, true);
        const feedReader = (0, utils_1.graffitiFeedReaderFromTopic)(bee, topic);
        let aggregatedList = [];
        const feedEntry = await feedReader.download();
        usersFeedIndex = parseInt(feedEntry.feedIndexNext, constants_1.HEX_RADIX);
        // Go back, until we find an overwrite commit
        for (let i = usersFeedIndex - 1; i >= 0; i--) {
            const feedEntry = await feedReader.download({ index: i });
            const data = await bee.downloadData(feedEntry.reference);
            const objectFromFeed = data.json();
            const validUsers = objectFromFeed.users.filter((user) => (0, utils_1.validateUserObject)(user));
            if (objectFromFeed.overwrite) { // They will have index that was already written to the object by Activity Analysis writer
                const usersBatch = validUsers;
                aggregatedList = [...aggregatedList, ...usersBatch];
                //TODO either quit, or check just the previous message
                // because that might be a registration, that was not recorded yet, in overwrite commit message
                // We could go back until we find a timestamp, that has lower timestamp than now-IDLE
                break;
            }
            else { // These do not have index, but we can initialize them to 0
                const userTopicString = (0, utils_1.generateUserOwnedFeedId)(topic, validUsers[0].address);
                const res = await (0, utils_1.getLatestFeedIndex)(bee, bee.makeFeedTopic(userTopicString), validUsers[0].address);
                const newUser = {
                    ...validUsers[0],
                    index: res.latestIndex
                };
                aggregatedList = [...aggregatedList, newUser];
            }
        }
        await setUsers(aggregatedList);
    }
    catch (error) {
        console.error('Init users error: ', error);
        throw error;
    }
    finally {
        emitStateEvent(constants_1.EVENTS.LOADING_INIT_USERS, false);
    }
}
exports.initUsers = initUsers;
// Checks if a given Ethereum address is registered or not
// Should be called from outside the library, for example React
function isRegistered(userAddress) {
    const findResult = users.findIndex((user) => user.address === userAddress);
    if (findResult === -1)
        return false;
    else
        return true;
}
exports.isRegistered = isRegistered;
// Registers the user for chat, will create a UsersFeedCommit object, and will write it to the Users feed
// Should be called from outside the library, for example React
async function registerUser(topic, { participant, key, stamp, nickName: username }) {
    try {
        emitStateEvent(constants_1.EVENTS.LOADING_REGISTRATION, true);
        const wallet = new ethers_1.ethers.Wallet(key);
        const address = wallet.address;
        if (address.toLowerCase() !== participant.toLowerCase()) {
            throw new Error('The provided address does not match the address derived from the private key');
        }
        startActivityAnalyzes(topic, address, stamp); // Every User is doing Activity Analysis, and one of them is selected to write the UsersFeed
        const alreadyRegistered = users.find((user) => user.address === participant);
        if (alreadyRegistered) {
            console.log('User already registered');
            return;
        }
        const timestamp = Date.now();
        const signature = (await wallet.signMessage(JSON.stringify({ username, address, timestamp })));
        const newUser = {
            address,
            username,
            timestamp,
            signature,
        };
        if (!(0, utils_1.validateUserObject)(newUser)) {
            throw new Error('User object validation failed');
        }
        await setUsers([...users, { ...newUser, index: -1 }]);
        const uploadObject = {
            users: [newUser],
            overwrite: false
        };
        const userRef = await (0, utils_1.uploadObjectToBee)(bee, uploadObject, stamp);
        if (!userRef)
            throw new Error('Could not upload user to bee');
        const feedWriter = (0, utils_1.graffitiFeedWriterFromTopic)(bee, topic);
        try {
            await feedWriter.upload(stamp, userRef.reference);
        }
        catch (error) {
            if ((0, utils_1.isNotFoundError)(error)) {
                await feedWriter.upload(stamp, userRef.reference, { index: 0 });
            }
        }
    }
    catch (error) {
        console.error(error);
        throw new Error(`There was an error while trying to register user (chatroom): ${error}`);
    }
    finally {
        emitStateEvent(constants_1.EVENTS.LOADING_REGISTRATION, false);
    }
}
exports.registerUser = registerUser;
// Every User is doing Activity Analysis, and one of them is selected to write the UsersFeed
async function startActivityAnalyzes(topic, ownAddress, stamp) {
    try {
        console.info("Starting Activity Analysis...");
        removeIdleUsersInterval = setInterval(() => removeIdleUsers(topic, ownAddress, stamp), constants_1.REMOVE_INACTIVE_USERS_INTERVAL);
    }
    catch (error) {
        console.error(error);
        throw new Error('Could not start activity analysis');
    }
}
// Used for Activity Analysis, creates or updates entry in the activity table
async function updateUserActivityAtRegistration() {
    try {
        for (let i = 0; i < newlyResigeredUsers.length; i++) {
            const address = newlyResigeredUsers[i].address;
            console.info(`New user registered. Inserting ${newlyResigeredUsers[i].timestamp} to ${address}`);
            if (userActivityTable[address]) // Update entry
                userActivityTable[address].timestamp = newlyResigeredUsers[i].timestamp;
            else // Create new entry
                userActivityTable[address] = {
                    timestamp: newlyResigeredUsers[i].timestamp,
                    readFails: 0
                };
        }
        console.log("User Activity Table: ", userActivityTable);
    }
    catch (error) {
        console.error(error);
        throw new Error('There was an error while processing new user registration in updateUserActivityAtRegistration');
    }
}
// Used for Activity Analysis, saves last message timestamp into activity table
async function updateUserActivityAtNewMessage(theNewMessage) {
    try {
        console.log("New message (updateUserActivityAtNewMessage): ", theNewMessage);
        userActivityTable[theNewMessage.address] = {
            timestamp: theNewMessage.timestamp,
            readFails: 0
        };
        console.log("User Activity Table (new message received): ", userActivityTable);
    }
    catch (error) {
        console.error(error);
        throw new Error('There wasn an error while processing new message on streamer side');
    }
}
// Every user is taking part in removeIdleUsers (Activity Analysis), but only one of them will be selected, for writting the Users feed 
// This selection is pseudo-random, and it should select the same user in every app instance
async function removeIdleUsers(topic, ownAddress, stamp) {
    try {
        console.log(`UserActivity table inside removeIdleUsers: `, userActivityTable);
        if (removeIdleIsRunning) {
            console.warn("Previous removeIdleUsers is still running");
            //TODO debug this
            // we could do some statistics about how slow is this node, so it will select it with less chance
            return;
        }
        removeIdleIsRunning = true;
        const activeUsers = (0, utils_1.getActiveUsers)(users, userActivityTable);
        if (activeUsers.length === 0) {
            console.info("There are no active users, Activity Analysis will continue when a user registers.");
            await writeUsersFeedCommit(topic, stamp, activeUsers);
            if (removeIdleUsersInterval)
                clearInterval(removeIdleUsersInterval);
            removeIdleIsRunning = false;
            return;
        }
        const selectedUser = (0, utils_1.selectUsersFeedCommitWriter)(activeUsers);
        if (selectedUser === ownAddress) {
            await writeUsersFeedCommit(topic, stamp, activeUsers);
        }
        removeIdleIsRunning = false;
    }
    catch (error) {
        removeIdleIsRunning = false;
        console.error(error);
        throw new Error('There was an error while removing idle users from the Users feed');
    }
}
// Write a UsersFeedCommit to the Users feed, which might remove some inactive users from the readMessagesForAll loop
async function writeUsersFeedCommit(topic, stamp, activeUsers) {
    try {
        console.info("The user was selected for submitting the UsersFeedCommit! (removeIdleUsers)");
        const uploadObject = {
            users: activeUsers,
            overwrite: true
        };
        const userRef = await (0, utils_1.uploadObjectToBee)(bee, uploadObject, stamp);
        if (!userRef)
            throw new Error('Could not upload user list to bee');
        const feedWriter = (0, utils_1.graffitiFeedWriterFromTopic)(bee, topic, { timeout: 8000 });
        await feedWriter.upload(stamp, userRef.reference);
        console.log("Upload was successful!");
    }
    catch (error) {
        console.error(error);
        throw new Error('There was an error while writing UsersFeedCommit to the Users feed');
    }
}
// Adds a getNewUsers to the usersQueue, which will fetch new users
function enqueueUserFetch(topic) {
    if (!usersQueue) {
        usersQueue = new asyncQueue_1.AsyncQueue({ indexed: false, waitable: true, max: 1 });
    }
    return () => usersQueue.enqueue((index) => getNewUsers(topic));
}
exports.enqueueUserFetch = enqueueUserFetch;
// Reads the Users feed, and changes the users object, accordingly
async function getNewUsers(topic) {
    try {
        emitStateEvent(constants_1.EVENTS.LOADING_USERS, true);
        const feedReader = (0, utils_1.graffitiFeedReaderFromTopic)(bee, topic);
        const feedEntry = await feedReader.download({ index: usersFeedIndex });
        const data = await bee.downloadData(feedEntry.reference);
        const objectFromFeed = data.json();
        console.log("New UsersFeedCommit received! ", objectFromFeed);
        const validUsers = objectFromFeed.users.filter((user) => (0, utils_1.validateUserObject)(user));
        let newUsers = [];
        if (!objectFromFeed.overwrite) {
            // Registration
            newUsers = [...users];
            const userTopicString = (0, utils_1.generateUserOwnedFeedId)(topic, validUsers[0].address);
            const res = await (0, utils_1.getLatestFeedIndex)(bee, bee.makeFeedTopic(userTopicString), validUsers[0].address);
            const theNewUser = {
                ...validUsers[0],
                index: res.latestIndex
            };
            newUsers.push(theNewUser);
            newlyResigeredUsers.push(theNewUser);
        }
        else {
            // Overwrite
            newUsers = (0, utils_1.removeDuplicateUsers)([...newlyResigeredUsers, ...validUsers]);
            newlyResigeredUsers = [];
        }
        await setUsers((0, utils_1.removeDuplicateUsers)(newUsers));
        usersFeedIndex++; // We assume that download was successful. Next time we are checking next index.
        // update userActivityTable
        updateUserActivityAtRegistration();
        emitStateEvent(constants_1.EVENTS.LOADING_USERS, false);
    }
    catch (error) {
        if (error instanceof Error) {
            if (error.message.includes("timeout")) {
                console.info(`Timeout exceeded.`);
                reqTimeAvg.addValue(constants_1.MAX_TIMEOUT);
            }
            else {
                if (!(0, utils_1.isNotFoundError)(error)) {
                    console.error(error);
                    throw new Error('There was an error in the getNewUsers function');
                }
            }
        }
    }
}
// Goes through the users object, and enqueues a readMessage for each assumably active user
function readMessagesForAll(topic) {
    if (!messagesQueue) {
        messagesQueue = new asyncQueue_1.AsyncQueue({ indexed: false, waitable: true, max: 4 });
    }
    return async () => {
        const isWaiting = await messagesQueue.waitForProcessing();
        if (isWaiting) {
            return;
        }
        for (const user of users) {
            reqCount++;
            //TODO remove
            console.info(`Request enqueued. Total request count: ${reqCount}`);
            messagesQueue.enqueue(() => readMessage(user, topic));
        }
    };
}
exports.readMessagesForAll = readMessagesForAll;
// Reads one message, from a user's own feed
async function readMessage(user, rawTopic) {
    try {
        const chatID = (0, utils_1.generateUserOwnedFeedId)(rawTopic, user.address);
        const topic = bee.makeFeedTopic(chatID);
        let currIndex = user.index;
        if (user.index === -1) {
            console.warn("WARNING! No index found!");
            const { latestIndex, nextIndex } = await (0, utils_1.getLatestFeedIndex)(bee, topic, user.address);
            currIndex = latestIndex === -1 ? nextIndex : latestIndex;
        }
        adjustParamerets(rawTopic);
        // We measure the request time with the first Bee API request, with the second request, we do not do this, because it is very similar
        const feedReader = bee.makeFeedReader('sequence', topic, user.address, { timeout: constants_1.MAX_TIMEOUT });
        const start = Date.now();
        const recordPointer = await feedReader.download({ index: currIndex });
        const end = Date.now();
        reqTimeAvg.addValue(end - start);
        // We download the actual message data
        const data = await bee.downloadData(recordPointer.reference);
        const messageData = JSON.parse(new TextDecoder().decode(data));
        //const newUsers = users.map((u) => (u.address === user.address ? { ...u, index: currIndex + 1 } : u));
        const uIndex = users.findIndex((u) => (u.address === user.address));
        const newUsers = users;
        if (newUsers[uIndex])
            newUsers[uIndex].index = currIndex + 1; // If this User was dropped, we won't increment it's index, but Streamer will
        await setUsers(newUsers);
        // If the message is relatively new, we insert it to messages array, otherwise, we drop it
        if (messageData.timestamp + constants_1.IDLE_TIME * 2 > Date.now()) {
            messages.push(messageData);
            // Update userActivityTable
            updateUserActivityAtNewMessage(messageData);
            messagesIndex++;
        }
        // TODO - discuss with the team
        /*if (messages.length > 300) {
          messages.shift();
        }*/
        emitter.emit(constants_1.EVENTS.RECEIVE_MESSAGE, messages);
    }
    catch (error) {
        if (error instanceof Error) {
            if (error.message.includes("timeout")) {
                console.info(`Timeout of ${constants_1.MAX_TIMEOUT} exceeded for readMessage.`);
            }
            else {
                if (!(0, utils_1.isNotFoundError)(error)) {
                    if (userActivityTable[user.address])
                        userActivityTable[user.address].readFails++; // We increment read fail count
                    console.error(error);
                    throw new Error('There was an error in the readMessage function');
                }
            }
        }
    }
}
// Adjusts maxParallel and message fetch interval
//TODO this might be an utils function, but we need to pass a lot of paramerers, and in the other direction as well (return)
function adjustParamerets(topic) {
    // Adjust max parallel request count, based on avg request time, which indicates, how much the node is overloaded
    if (reqTimeAvg.getAverage() > constants_1.DECREASE_LIMIT)
        messagesQueue.decreaseMax();
    if (reqTimeAvg.getAverage() < constants_1.INCREASE_LIMIT)
        messagesQueue.increaseMax(users.length * 4); // *4 is just for simulation purposes, it should be exactly users.length
    // Adjust message fetch interval
    if (reqTimeAvg.getAverage() > constants_1.FETCH_INTERVAL_INCREASE_LIMIT) {
        if (mInterval + constants_1.F_STEP <= constants_1.MESSAGE_FETCH_MAX) {
            mInterval = mInterval + constants_1.F_STEP;
            if (messageFetchInterval)
                clearInterval(messageFetchInterval);
            messageFetchInterval = setInterval(readMessagesForAll(topic), mInterval);
            console.info(`Increased message fetch interval to ${mInterval} ms`);
        }
    }
    if (reqTimeAvg.getAverage() < constants_1.FETCH_INTERVAL_DECREASE_LIMIT) {
        if (mInterval - constants_1.F_STEP > constants_1.MESSAGE_FETCH_MIN) {
            mInterval = mInterval - constants_1.F_STEP;
            if (messageFetchInterval)
                clearInterval(messageFetchInterval);
            messageFetchInterval = setInterval(readMessagesForAll(topic), mInterval);
            console.info(`Decreased message fetch interval to ${mInterval - constants_1.F_STEP} ms`);
        }
    }
}
// Sends a message to the user's own feed
async function sendMessage(address, topic, messageObj, stamp, privateKey) {
    try {
        if (!privateKey)
            throw 'Private key is missing';
        const feedID = (0, utils_1.generateUserOwnedFeedId)(topic, address);
        const feedTopicHex = bee.makeFeedTopic(feedID);
        if (!ownIndex) {
            const { nextIndex } = await (0, utils_1.getLatestFeedIndex)(bee, feedTopicHex, address);
            ownIndex = nextIndex;
        }
        const msgData = await (0, utils_1.uploadObjectToBee)(bee, messageObj, stamp);
        console.log('msgData', msgData);
        if (!msgData)
            throw 'Could not upload message data to bee';
        const feedWriter = bee.makeFeedWriter('sequence', feedTopicHex, privateKey);
        const ref = await feedWriter.upload(stamp, msgData.reference, { index: ownIndex });
        ownIndex++;
        return ref;
    }
    catch (error) {
        console.error(`There was an error while trying to write own feed (chat), index: ${ownIndex}, message: ${messageObj.message}: ${error}  `);
        throw new Error('Could not send message');
    }
}
exports.sendMessage = sendMessage;
// Writes the users object, will avoid collision with other write operation
async function setUsers(newUsers) {
    return (0, utils_1.retryAwaitableAsync)(async () => {
        if (usersLoading) {
            throw new Error('Users are still loading');
        }
        usersLoading = true;
        users = newUsers;
        usersLoading = false;
    });
}
// Emit event about state change
function emitStateEvent(event, value) {
    if (eventStates[event] !== value) {
        eventStates[event] = value;
        emitter.emit(event, value);
    }
}
function getUserCount() {
    return users.length;
}
exports.getUserCount = getUserCount;
