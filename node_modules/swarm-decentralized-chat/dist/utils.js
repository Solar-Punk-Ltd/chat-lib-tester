"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getActiveUsers = exports.selectUsersFeedCommitWriter = exports.RunningAverage = exports.isNotFoundError = exports.getLatestFeedIndex = exports.generateGraffitiFeedMetadata = exports.graffitiFeedReaderFromTopic = exports.graffitiFeedWriterFromTopic = exports.uploadObjectToBee = exports.retryAwaitableAsync = exports.incrementHexString = exports.sleep = exports.numberToFeedIndex = exports.removeDuplicateUsers = exports.orderMessages = exports.validateUserObject = exports.generateUserOwnedFeedId = exports.generateUsersFeedId = void 0;
const ethers_1 = require("ethers");
const crypto = __importStar(require("crypto"));
const bee_js_1 = require("@ethersphere/bee-js");
const constants_1 = require("./constants");
// Generate an ID for the feed, that will be connected to the stream, as Users list
function generateUsersFeedId(topic) {
    return `${topic}_EthercastChat_Users`;
}
exports.generateUsersFeedId = generateUsersFeedId;
// Generate an ID for the feed, that is owned by a single user, who is writing messages to the chat
function generateUserOwnedFeedId(topic, userAddress) {
    return `${topic}_EthercastChat_${userAddress}`;
}
exports.generateUserOwnedFeedId = generateUserOwnedFeedId;
// Validates a User object, including incorrect type, and signature
function validateUserObject(user) {
    try {
        if (typeof user.username !== 'string')
            throw 'username should be a string';
        if (typeof user.address !== 'string')
            throw 'address should be a string';
        if (typeof user.timestamp !== 'number')
            throw 'timestamp should be number';
        if (typeof user.signature !== 'string')
            throw 'signature should be a string';
        // Check for absence of extra properties
        const allowedProperties = ['username', 'address', 'timestamp', 'signature', 'index'];
        const extraProperties = Object.keys(user).filter((key) => !allowedProperties.includes(key));
        if (extraProperties.length > 0) {
            throw `Unexpected properties found: ${extraProperties.join(', ')}`;
        }
        // Create the message that is signed, and validate the signature
        const message = {
            username: user.username,
            address: user.address,
            timestamp: user.timestamp,
        };
        const returnedAddress = ethers_1.ethers.utils.verifyMessage(JSON.stringify(message), user.signature);
        if (returnedAddress !== user.address)
            throw 'Signature verification failed!';
        return true;
    }
    catch (error) {
        console.error('This User object is not correct: ', error);
        return false;
    }
}
exports.validateUserObject = validateUserObject;
// Returns timesstamp ordered messages
function orderMessages(messages) {
    return messages.sort((a, b) => a.timestamp - b.timestamp);
}
exports.orderMessages = orderMessages;
// Remove duplicated elements from users object
function removeDuplicateUsers(users) {
    const userMap = {};
    users.forEach(user => {
        if (!userMap[user.address]) {
            userMap[user.address] = user;
        }
        else {
            const existingUser = userMap[user.address];
            if (user.timestamp > existingUser.timestamp ||
                (user.timestamp === existingUser.timestamp && user.index > existingUser.index)) {
                userMap[user.address] = user;
            }
        }
    });
    return Object.values(userMap);
}
exports.removeDuplicateUsers = removeDuplicateUsers;
// getConsensualPrivateKey will generate a private key, that is used for the Graffiti-feed (which is a public feed, for user registration)
function getConsensualPrivateKey(resource) {
    if (bee_js_1.Utils.isHexString(resource) && resource.length === 64) {
        return bee_js_1.Utils.hexToBytes(resource);
    }
    return bee_js_1.Utils.keccak256Hash(resource);
}
// getGraffitiWallet generates a Graffiti wallet, from provided private key (see getConsensualPrivateKey)
function getGraffitiWallet(consensualPrivateKey) {
    const privateKeyBuffer = ethers_1.utils.hexlify(consensualPrivateKey);
    return new ethers_1.Wallet(privateKeyBuffer);
}
// Serializes a js object, into Uint8Array
function serializeGraffitiRecord(record) {
    return new TextEncoder().encode(JSON.stringify(record));
}
// Creates feed-index-format index, from a number
function numberToFeedIndex(index) {
    const bytes = new Uint8Array(8);
    const dv = new DataView(bytes.buffer);
    dv.setUint32(4, index);
    return bee_js_1.Utils.bytesToHex(bytes);
}
exports.numberToFeedIndex = numberToFeedIndex;
// General sleep function, usage: await sleep(ms)
function sleep(delay) {
    return new Promise((resolve) => {
        setTimeout(resolve, delay);
    });
}
exports.sleep = sleep;
// Increment hex string, default value is 1
function incrementHexString(hexString, i = 1n) {
    const num = BigInt('0x' + hexString);
    return (num + i).toString(constants_1.HEX_RADIX).padStart(constants_1.HEX_RADIX, '0');
}
exports.incrementHexString = incrementHexString;
// retryAwaitableAsync will retry a promise if fails, default retry number is 3, default delay between attempts is 250 ms
async function retryAwaitableAsync(fn, retries = 3, delay = 250) {
    return new Promise((resolve, reject) => {
        fn()
            .then(resolve)
            .catch((error) => {
            if (retries > 0) {
                console.log(`Retrying... Attempts left: ${retries}. Error: ${error.message}`);
                setTimeout(() => {
                    retryAwaitableAsync(fn, retries - 1, delay)
                        .then(resolve)
                        .catch(reject);
                }, delay);
            }
            else {
                console.error(`Failed after ${retries} initial attempts. Last error: ${error.message}`);
                reject(error);
            }
        });
    });
}
exports.retryAwaitableAsync = retryAwaitableAsync;
// Uploads a js object to Swarm, a valid stamp needs to be provided
async function uploadObjectToBee(bee, jsObject, stamp) {
    try {
        const result = await bee.uploadData(stamp, serializeGraffitiRecord(jsObject), { redundancyLevel: 4 });
        return result;
    }
    catch (error) {
        console.error(`There was an error while trying to upload object to Swarm: ${error}`);
        return null;
    }
}
exports.uploadObjectToBee = uploadObjectToBee;
// Creates a Graffiti feed writer from provided topic, Bee request options can be provided, e.g. timeout
function graffitiFeedWriterFromTopic(bee, topic, options) {
    const { consensusHash, graffitiSigner } = generateGraffitiFeedMetadata(topic);
    return bee.makeFeedWriter('sequence', consensusHash, graffitiSigner, options);
}
exports.graffitiFeedWriterFromTopic = graffitiFeedWriterFromTopic;
// Creates a Graffiti feed reader from provided topic, Bee request options can be provided, e.g. timeout
function graffitiFeedReaderFromTopic(bee, topic, options) {
    const { consensusHash, graffitiSigner } = generateGraffitiFeedMetadata(topic);
    return bee.makeFeedReader('sequence', consensusHash, graffitiSigner.address, options);
}
exports.graffitiFeedReaderFromTopic = graffitiFeedReaderFromTopic;
// generateGraffitiFeedMetadata will give back a consensus hash, and a Signer, from provided topic
function generateGraffitiFeedMetadata(topic) {
    const roomId = generateUsersFeedId(topic);
    const privateKey = getConsensualPrivateKey(roomId);
    const wallet = getGraffitiWallet(privateKey);
    const graffitiSigner = {
        address: bee_js_1.Utils.hexToBytes(wallet.address.slice(2)),
        sign: async (data) => {
            return await wallet.signMessage(data);
        },
    };
    const consensusHash = bee_js_1.Utils.keccak256Hash(constants_1.CONSENSUS_ID);
    return {
        consensusHash,
        graffitiSigner,
    };
}
exports.generateGraffitiFeedMetadata = generateGraffitiFeedMetadata;
// getLatestFeedIndex will give back latestIndex and nextIndex, if download succeeds, if not, latestIndex will be -1, and nextIndex is 0
async function getLatestFeedIndex(bee, topic, address) {
    try {
        const feedReader = bee.makeFeedReader('sequence', topic, address);
        const feedEntry = await feedReader.download();
        console.log("feedEntry (getLatestFeedIndex): ", feedEntry);
        const latestIndex = parseInt(feedEntry.feedIndex.toString(), constants_1.HEX_RADIX);
        const nextIndex = parseInt(feedEntry.feedIndexNext, constants_1.HEX_RADIX);
        return { latestIndex, nextIndex };
    }
    catch (error) {
        if (isNotFoundError(error)) {
            return { latestIndex: -1, nextIndex: 0 };
        }
        throw error;
    }
}
exports.getLatestFeedIndex = getLatestFeedIndex;
// TODO: why bee-js do this?
// status is undefined in the error object
// Determines if the error is about 'Not Found'
function isNotFoundError(error) {
    return error.stack.includes('404') || error.message.includes('Not Found') || error.message.includes('404');
}
exports.isNotFoundError = isNotFoundError;
// Calculates and stores average, used for request time averaging
class RunningAverage {
    constructor(maxSize) {
        this.maxSize = maxSize;
        this.values = [];
        this.sum = 0;
    }
    addValue(newValue) {
        if (this.values.length === this.maxSize) {
            const removedValue = this.values.shift();
            if (removedValue !== undefined) {
                this.sum -= removedValue;
            }
        }
        this.values.push(newValue);
        this.sum += newValue;
        console.log("Current average: ", this.getAverage());
    }
    getAverage() {
        if (this.values.length === 0) {
            return 200;
        }
        return this.sum / this.values.length;
    }
}
exports.RunningAverage = RunningAverage;
// selectUsersFeedCommitWriter will select a user who will write a UsersFeedCommit object to the feed
function selectUsersFeedCommitWriter(activeUsers) {
    const minUsersToSelect = 3;
    const numUsersToselect = Math.max(Math.ceil(activeUsers.length * 0.3), minUsersToSelect); // Select top 30% of activeUsers, but minimum 1
    const sortedActiveUsers = activeUsers.sort((a, b) => b.timestamp - a.timestamp); // Sort activeUsers by timestamp
    const mostActiveUsers = sortedActiveUsers.slice(0, numUsersToselect); // Top 30% but minimum 3 (minUsersToSelect)
    console.log("Most active users: ", mostActiveUsers);
    const sortedMostActiveAddresses = mostActiveUsers.map((user) => user.address).sort();
    const seedString = sortedMostActiveAddresses.join(','); // All running instances should have the same string at this time
    const hash = crypto.createHash('sha256').update(seedString).digest('hex'); // Hash should be same in all computers that are in this chat
    const randomIndex = parseInt(hash, 16) % mostActiveUsers.length; // They should have the same number, thus, selecting the same user
    return mostActiveUsers[randomIndex].address;
}
exports.selectUsersFeedCommitWriter = selectUsersFeedCommitWriter;
// Gives back the currently active users, based on idle time calculation
function getActiveUsers(users, userActivityTable) {
    const idleMs = {};
    const now = Date.now();
    for (const rawKey in userActivityTable) {
        const key = rawKey;
        idleMs[key] = now - userActivityTable[key].timestamp;
    }
    console.log("Users inside removeIdle: ", users);
    const activeUsers = users.filter((user) => {
        const userAddr = user.address;
        if (!userActivityTable[userAddr]) {
            userActivityTable[userAddr] = {
                timestamp: user.timestamp,
                readFails: 0
            };
            return true;
        }
        return idleMs[userAddr] < constants_1.IDLE_TIME;
    });
    return activeUsers;
}
exports.getActiveUsers = getActiveUsers;
